РЕАЛИЗАЦИЯ:
дан двудольный граф в виде явно разбитого на две доли графа.
Вершины в обеих долях занумерованы независимо, т.е. первая доля — с номерами 1...n, вторая — с номерами 1...k.

n — число вершин в первой доле,
k — во второй доле, 
m - число ребер

    n,k,m = map(int, input('Please enter three digit separated by space: ').split())


graph[] — список рёбер из вершины v первой доли (т.е. список номеров вершин, в которые ведут эти рёбра из v). 

    graph = [[] for i in range(0,n)]
    
    заполняем массив списком номеров вершин второй доли в которые ведут ребра из каждой вершины первой доли:
    for i in range(0,m):
        v,w = map(int, input('Please enter two vertex num separated by space: ').split())
        v -= 1
        w -= 1
        graph[v].append(w)

3 вспомогательных массива:
mt, seen и used. 

mt — содержит в себе информацию о текущем паросочетании. 
Информация эта содержится только для вершин второй доли: 
mt[i] — это номер вершины первой доли, связанной ребром с вершиной i второй доли 
(или -1, если никакого ребра паросочетания из i не выходит). 

used — обычный массив "посещённостей" вершин в обходе в глубину 
(он нужен, просто чтобы обход в глубину не заходил в одну вершину дважды).

seen - тоже массив посещенностей вершины для улучшения точности поиска наибольшего паросочетания 
(мы находим эту вершину, записываем ребро из нее в mt и запускаем поиск максимального паросочетания из нее)

    seen = [False for i in range(0,n)]
    used = [False for i in range(0,n)]
    mt = [-1 for i in range(0,k)]


Функция kuhn — обход в глубину. Она возвращает true, если ей удалось найти увеличивающую цепь из вершины v, 
при этом считается, что эта функция уже произвела чередование паросочетания вдоль найденной цепи.

Внутри функции просматриваются все рёбра, исходящие из вершины v первой доли, и затем проверяется: 
если это ребро ведёт в ненасыщенную вершину w, либо если эта вершина w насыщена, 
но удаётся найти увеличивающую цепь рекурсивным запуском из mt[w], 
то мы говорим, что мы нашли увеличивающую цепь, и перед возвратом из функции с результатом true 
производим чередование в текущем ребре: перенаправляем ребро, смежное с w, в вершину v.


В основной программе сначала указывается, что текущее паросочетание — пустое (список mt заполняется числами -1).

Поскольку при вызове функции kuhn в основном цикле предполагается, что текущая вершина ещё не входит в паросочетание, 
то нужно добавить соответствующую проверку. 
До основного цикла алгоритма найдём каким-нибудь простым алгоритмом произвольное паросочетание (простым эвристическим алгоритмом): 
    for i in range(0,n):
        for j in range(0,len(graph[i])):
            if (mt[graph[i][j]] == -1):
                mt[graph[i][j]] = i
                seen[i] = True
                break
и лишь затем будем выполнять цикл с вызовами функции kuhn(), который будет улучшать это паросочетание.

Затем (функция solve()) перебирается вершина v первой доли, и из неё запускается обход в глубину kuhn, 
предварительно обнулив массив used.

Искомое максимальное паросочетание содержится в массиве mt.

